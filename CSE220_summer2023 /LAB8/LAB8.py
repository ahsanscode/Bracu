# -*- coding: utf-8 -*-
"""LAB 8

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x1Z9m378esazX4KmXP9PdrLLOCeW-0Wf
"""

class BTNode:
  def __init__(self, elem):
    self.elem = elem
    self.right = None
    self.left = None

def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)

def tree_construction(arr, i = 1):
  if i>=len(arr) or arr[i] == None:
    return None
  p = BTNode(arr[i])
  p.left = tree_construction(arr, 2*i)
  p.right = tree_construction(arr, 2*i+1)
  return p


root2 = tree_construction([None, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', None, None, None, 'I', 'J', None, 'k'])
inorder(root2)

"""Task 1"""

def convert_mirror(root):
  if root == None:
    return

  temp = root.left
  root.left = root.right
  root.right = temp
  convert_mirror(root.left)
  convert_mirror(root.right)
  return root


#DRIVER CODE
root = BTNode(10)
n1 = BTNode(20)
n2 = BTNode(30)
n3 = BTNode(40)
n4 = BTNode(60)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  40 20 60 10 30
print()

root2 = convert_mirror(root)
print('Mirrored Tree Inorder Traversal: ', end = ' ')
inorder(root2) #Mirrored Tree Inorder Traversal:  30 10 60 20 40

"""Task 2"""

def helper(root,dictx,c):

  if root==None:
    return None
  if c not in dictx:
    dictx[c]=root.elem
  if dictx[c]<root.elem:
    dictx[c]=root.elem
  i=helper(root.left,dictx,c+1)
  i=helper(root.right,dictx,c+1)
  return dictx
def largest_level(root):
  dictx={}
  return helper(root,dictx,c=0)
#DRIVER CODE
root = tree_construction([None, 4,9,2,3,5,None,7])
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  3 9 5 4 2 7
print()
print('Level Wise Largest Value: ', end = ' ')
print(largest_level(root)) #Level Wise Largest Value:  {0: 4, 1: 9, 2: 7}

"""Task 3"""

def inorder_successor(root, x):
    while root!=None:
        if root.elem > x.elem:
            successor = root
            root = root.left
        else:
            root = root.right

    return successor


#DRIVER CODE
root = BTNode(20)
n1 = BTNode(8)
n2 = BTNode(22)
n3 = BTNode(4)
n4 = BTNode(12)
n5 = BTNode(10)
n6 = BTNode(14)

root.left = n1
root.right = n2

n1.left = n3
n1.right = n4

n4.left = n5
n4.right = n6
def inorder(root):
  if root == None:
    return

  inorder(root.left)
  print(root.elem, end = ' ')
  inorder(root.right)
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root) #Given Tree Inorder Traversal:  4 8 10 12 14 20 22
print()

x = n1
print(f'Inorder successor of node {x.elem}: {inorder_successor(root, x).elem}') #Inorder successor of node 8: 10

"""Task 4"""

c = 0
def countx(root):
  global c
  if root == None:
    return

  countx(root.left)
  c+=1
  countx(root.right)


arr = None

x = 0

def my_f(root,k,i=1):

  global x
  if root == None:
    return

  my_f(root.left,k,i+1)

  if k == i:
    arr[x] = root
    x+=1

  my_f(root.right,k,i+1)


def kth_smallest(root,k,i=0):
  global arr
  countx(root)
  arr = [None]*c
  my_f(root,k)
  temp = None
  if type(arr[0].elem) == int:
    temp = arr[0]
  for var in range(1,x):
    if type(arr[var].elem)  != int:
      break
    if arr[var].elem < temp.elem:
      temp = arr[var]
  return temp

#DRIVER CODE
root = tree_construction([None, 9,5,11,4,7,None,12,None,None,6,8,None,None,None,None])
print('Given Tree Inorder Traversal: ', end = ' ')
inorder(root)
print()
k = 4
print(kth_smallest(root,k).elem)

"""Bonus"""

#WRITE THE FUNCTION AND DRIVER CODE BY YOURSELF
